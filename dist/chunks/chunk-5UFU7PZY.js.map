{
  "version": 3,
  "sources": ["../../src/utils/handle-hash-link-navigation.ts", "../../src/utils/stop-page-scroll.ts", "../../src/components/nav.ts"],
  "sourcesContent": ["import { setEndState } from '../pages/home/sections/intro-scene';\n\nconst handleHashLinkNavigation = () => {\n  const navbar = document.querySelector('#navbar');\n\n  const hashLinks = navbar?.querySelectorAll('a[href^=\"/#\"]');\n\n  if (hashLinks && hashLinks.length > 0) {\n    hashLinks.forEach((link) => {\n      // Create button element and copy attributes/styling from link\n      const button = document.createElement('button');\n      button.textContent = link.textContent;\n      button.className = link.className;\n      button.setAttribute('data-href', link.getAttribute('href') || '');\n\n      // Replace link with button\n      link.parentNode?.replaceChild(button, link);\n\n      button.addEventListener('click', (event) => {\n        event.preventDefault();\n        setEndState();\n        const href = button.getAttribute('data-href');\n        // console.log('Button clicked:', href);\n\n        if (!href) {\n          // console.log('No href found on button');\n          return;\n        }\n\n        if (window.location.pathname !== '/') {\n          window.location.href = href;\n          return;\n        }\n\n        const hash = href.replace('/', '');\n        const element = document.querySelector(hash);\n\n        if (!element) return;\n\n        const navHeight = navbar?.getBoundingClientRect().height || 0;\n        const elementPosition = (element as HTMLElement).offsetTop;\n\n        const scrollTo = elementPosition - navHeight;\n\n        window.scrollTo({\n          top: scrollTo,\n          behavior: 'smooth',\n        });\n      });\n    });\n  }\n};\n\nexport { handleHashLinkNavigation };\n", "let observer: MutationObserver | null = null;\n\n/**\n * Toggles the ability to scroll the page body and sets up observers for menu state\n * @param shouldStop - Boolean indicating whether to prevent (true) or allow (false) scrolling\n * @param menuElement - Optional element to observe for style changes\n */\nconst stopPageScroll = (shouldStop: boolean, menuElement?: HTMLElement) => {\n  const { body } = document;\n  const html = document.documentElement;\n\n  // If a menu element is provided, set up the observer\n  if (menuElement && !observer) {\n    observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.attributeName === 'style') {\n          const isOpen = menuElement.style.display !== 'none';\n          // Only apply scroll lock if menu is actually visible\n          if (isOpen) {\n            stopPageScroll(true);\n          } else {\n            stopPageScroll(false);\n          }\n        }\n      });\n    });\n\n    observer.observe(menuElement, {\n      attributes: true,\n      attributeFilter: ['style'],\n    });\n  }\n\n  if (shouldStop) {\n    // Only apply scroll lock if body isn't already locked\n    if (body.style.position !== 'fixed') {\n      // Store current scroll position\n      const { scrollY } = window;\n\n      // Prevent scrolling while maintaining position\n      body.style.position = 'fixed';\n      body.style.top = `-${scrollY}px`;\n      body.style.width = '100%';\n      html.style.scrollBehavior = 'auto';\n    }\n  } else {\n    // Only remove scroll lock if body is currently locked\n    if (body.style.position === 'fixed') {\n      // Re-enable scrolling and restore position\n      const scrollY = body.style.top;\n      body.style.position = '';\n      body.style.top = '';\n      body.style.width = '';\n      html.style.scrollBehavior = '';\n      window.scrollTo(0, parseInt(scrollY || '0') * -1);\n    }\n  }\n\n  return () => {\n    if (observer) {\n      observer.disconnect();\n      observer = null;\n    }\n  };\n};\n\nexport { stopPageScroll };\n", "import { gsap } from 'gsap';\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\n\nimport { handleHashLinkNavigation } from '$utils/handle-hash-link-navigation';\nimport { handleResize } from '$utils/handle-resize';\nimport { isDesktop } from '$utils/page-utils';\nimport { BREAKPOINTS } from '$utils/page-utils';\nimport { stopPageScroll } from '$utils/stop-page-scroll';\n\nimport { isPage } from '../utils/is-page';\n\n/**\n * Animates the logo in the navbar.\n * @returns A cleanup function to remove the event listener\n */\nconst animateNavLogo = (debug: boolean = false) => {\n  const SELECTORS = {\n    logo: '.navbar_logo',\n  };\n  const logo = document.querySelector(SELECTORS.logo);\n\n  if (!logo) {\n    console.error('Required logo element not found');\n    return;\n  }\n\n  // Register ScrollTrigger plugin\n  gsap.registerPlugin(ScrollTrigger);\n\n  const isHomepage = isPage('/');\n\n  const initAnimation = () => {\n    // Set initial state - hide the logo\n    gsap.set(logo, {\n      y: isHomepage ? -100 : 0,\n      opacity: 0,\n    });\n\n    // Create animation\n    if (isHomepage) {\n      // console.log('Creating homepage animation');\n      // Homepage animation with scroll trigger\n      const tl = gsap.timeline({\n        scrollTrigger: {\n          trigger: 'main',\n          start: '4% top',\n          end: 'top 0%',\n          scrub: false,\n          toggleActions: 'play none none reverse',\n          id: 'navLogoAnimation',\n          immediateRender: true,\n          markers: debug,\n          // onEnter: () => console.log('ScrollTrigger entered'),\n          // onLeave: () => console.log('ScrollTrigger left'),\n        },\n      });\n\n      // Animate the logo with y movement\n      tl.to(logo, {\n        y: 0,\n        opacity: 1,\n        duration: 0.2,\n        ease: 'power2.out',\n      });\n      // console.log('Homepage animation timeline created');\n\n      // Force ScrollTrigger to check its position immediately\n      ScrollTrigger.refresh();\n      // console.log('ScrollTrigger refreshed');\n    } else {\n      // console.log('Creating non-homepage animation');\n      // Other pages - just fade in immediately\n      gsap.to(logo, {\n        opacity: 1,\n        duration: 0.2,\n        ease: 'power2.out',\n      });\n    }\n  };\n\n  initAnimation();\n\n  return () => {\n    ScrollTrigger.getById('navLogoAnimation')?.kill();\n  };\n};\n\nconst SELECTORS = {\n  banner: '#nav-mobile-banner',\n  mobileMenu: '#nav-mobile-menu',\n  navbar: '#navbar',\n};\n\nconst getMobileMenu = () => {\n  const banner = document.querySelector(SELECTORS.banner) as HTMLElement;\n  const mobileMenu = document.querySelector(SELECTORS.mobileMenu) as HTMLElement;\n  const navbar = document.querySelector(SELECTORS.navbar) as HTMLElement;\n  return { banner, mobileMenu, navbar };\n};\n\n/**\n * Sets the padding of the mobile menu based on the height of the banner.\n * This ensures the mobile menu content appears below the banner when opened.\n * @returns A cleanup function to remove the event listener\n */\nconst navMenuPosition = () => {\n  // Only run on mobile and tablet\n  if (window.innerWidth >= BREAKPOINTS.TABLET) {\n    return () => {}; // Return empty cleanup function\n  }\n\n  const { banner, mobileMenu } = getMobileMenu();\n\n  if (!banner || !mobileMenu) {\n    console.error('Required banner or mobile menu element not found', {\n      banner: banner ? 'found' : 'missing',\n      mobileMenu: mobileMenu ? 'found' : 'missing',\n    });\n    return;\n  }\n\n  // Set padding based on banner height\n  const setPadding = () => {\n    // Only update padding if still on mobile/tablet\n    if (window.innerWidth < BREAKPOINTS.TABLET) {\n      const bannerHeight = banner.getBoundingClientRect().height;\n      const newPadding = `${bannerHeight}px`;\n      mobileMenu.style.paddingTop = newPadding;\n    }\n  };\n\n  // Add a delay to ensure banner height is calculated correctly after page load\n  setTimeout(() => {\n    setPadding();\n  }, 500);\n\n  // Update padding on window resize\n  handleResize(setPadding, 100, {\n    widthOnly: true,\n    threshold: 10,\n  });\n};\n\nlet cleanupScrollLock: (() => void) | undefined;\n\nconst handleMobileMenuOpen = () => {\n  const { mobileMenu } = getMobileMenu();\n  if (!mobileMenu) {\n    console.error('Required mobile menu element not found');\n    return;\n  }\n\n  // Clean up existing observer if present\n  if (cleanupScrollLock) {\n    cleanupScrollLock();\n    cleanupScrollLock = undefined;\n  }\n\n  // Only set up scroll lock observer on mobile/tablet\n  if (!isDesktop()) {\n    cleanupScrollLock = stopPageScroll(false, mobileMenu);\n  }\n\n  // Add resize handler to clean up observer when switching to desktop\n  const cleanupResize = handleResize(\n    () => {\n      if (isDesktop() && cleanupScrollLock) {\n        // Ensure scroll is unlocked and observer is disconnected\n        stopPageScroll(false);\n        cleanupScrollLock();\n        cleanupScrollLock = undefined;\n      } else if (!isDesktop() && !cleanupScrollLock) {\n        // Re-setup observer if we're back on mobile\n        cleanupScrollLock = stopPageScroll(false, mobileMenu);\n      }\n    },\n    100,\n    {\n      widthOnly: true,\n      threshold: 10,\n    }\n  );\n\n  return () => {\n    if (cleanupScrollLock) {\n      cleanupScrollLock();\n    }\n    if (cleanupResize) {\n      cleanupResize();\n    }\n  };\n};\n\n// const handleMobileNavAppear = () => {\n//   const { navbar } = getMobileMenu();\n//   if (!navbar) {\n//     console.error('Required navbar element not found');\n//     return;\n//   }\n\n//   let lastScrollY = window.scrollY;\n//   let isVisible = true;\n\n//   // GSAP timeline for nav animations\n//   const navTimeline = gsap.timeline({ paused: true });\n//   navTimeline\n//     .to(navbar, {\n//       yPercent: 0,\n//       duration: 0.2,\n//       ease: 'power3.inOut',\n//       delay: 0.2,\n//     })\n//     .to(\n//       navbar,\n//       {\n//         yPercent: -100,\n//         duration: 0.2,\n//         ease: 'power3.inOut',\n//         delay: 0.2,\n//       },\n//       '>'\n//     );\n\n//   const handleScroll = () => {\n//     const currentScrollY = window.scrollY;\n\n//     // Determine scroll direction\n//     if (currentScrollY > lastScrollY && isVisible) {\n//       // Scrolling down - hide nav\n//       navTimeline.play();\n//       isVisible = false;\n//     } else if (currentScrollY < lastScrollY && !isVisible) {\n//       // Scrolling up - show nav\n//       navTimeline.reverse();\n//       isVisible = true;\n//     }\n\n//     lastScrollY = currentScrollY;\n//   };\n\n//   // Add scroll listener with throttle\n//   let ticking = false;\n//   window.addEventListener('scroll', () => {\n//     if (!ticking) {\n//       window.requestAnimationFrame(() => {\n//         handleScroll();\n//         ticking = false;\n//       });\n//       ticking = true;\n//     }\n//   });\n// };\n\nconst initNav = () => {\n  animateNavLogo();\n  getMobileMenu();\n  handleHashLinkNavigation();\n  navMenuPosition();\n  handleMobileMenuOpen();\n  // if (isMobile()) {\n  //   handleMobileNavAppear();\n  // }\n};\n\nexport { animateNavLogo, getMobileMenu, initNav, navMenuPosition };\n"],
  "mappings": "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",
  "names": ["SELECTORS"]
}
